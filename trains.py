# -*- coding: utf-8 -*-
"""
=========================================
TRAINS.PY — Fetch live R-train data (config-driven)
=========================================

Reads train line, stations, and timing settings from config.json.
Handles only logic (no Streamlit). Can be used by Streamlit or CLI.

Author: Birgir
Version: 2025-10-29
"""

# ----------------------------
# 1) IMPORTS
# ----------------------------
import requests
from datetime import datetime, timedelta, timezone
from requests.exceptions import ReadTimeout, ConnectionError
import zoneinfo
import json
import os
import time

# ----------------------------
# 2) CONFIGURATION
# ----------------------------
import os, json, zoneinfo

# Determine config path relative to this file
CONFIG_PATH = os.path.join(os.path.dirname(__file__), "config.json")

def load_config():
    """
    Load configuration shared by all modules.
    Expects config.json generated by config.py.
    """
    if not os.path.exists(CONFIG_PATH):
        raise FileNotFoundError("⚠️ config.json not found — run config.py first.")
    with open(CONFIG_PATH, "r", encoding="utf-8") as f:
        return json.load(f)

# Load config once on import
cfg = load_config()

# --- Extract configuration values ---
TRAIN_LINE = cfg["TRAIN_LINE"]
STATIONS = cfg["STATIONS"]
HOME_STATIONS = cfg["HOME_STATIONS"]
PAST_MINUTES = cfg["PAST_MINUTES"]
FUTURE_MINUTES = cfg["FUTURE_MINUTES"]

TZ = zoneinfo.ZoneInfo("Europe/Helsinki")

# --- API headers ---
HEADERS = {
    "Digitraffic-User": cfg.get("USER_AGENT", "Birgir-ainola-dashboard/1.0")
}

# ----------------------------
# 3) TIME HELPERS
# ----------------------------
def parse_time(ts: str) -> datetime:
    """Convert ISO8601 string like '2024-01-26T12:05:00.000Z' → timezone-aware UTC datetime."""
    return datetime.fromisoformat(ts.replace("Z", "+00:00"))

def format_hki(dt: datetime) -> str:
    """Format datetime to Helsinki local time HH:MM."""
    return dt.astimezone(TZ).strftime("%H:%M")

# ----------------------------
# 4) FETCH FUNCTIONS
# ----------------------------
def fetch_station_window(station_code: str, before=PAST_MINUTES, after=FUTURE_MINUTES, limit=500, retries=2):
    """
    Fetch trains from Digitraffic API for a specific station.
    Retries automatically if network timeout occurs.
    """
    url = (
        f"https://rata.digitraffic.fi/api/v1/live-trains/station/{station_code}"
        f"?departing_trains={limit}&minutes_before_departure={before}&minutes_after_departure={after}"
    )

    for attempt in range(retries + 1):
        try:
            r = requests.get(url, headers=HEADERS, timeout=6)
            r.raise_for_status()
            return r.json()
        except (ConnectionError, ReadTimeout):
            if attempt == retries:
                return []
            time.sleep(0.4)  # short delay before retry

# ----------------------------
# 5) TRAIN LOGIC
# ----------------------------
def extract_best_time(row):
    """
    Return (text, best_dt) for the given timetable row.

    text → formatted string like:
        "08:34 → 08:39 (+5 min)" (if delayed)
        or just "08:34" if on time or no delay info.
    best_dt → datetime of actual or estimate (for sorting/comparisons)
    """
    sched = parse_time(row.get("scheduledTime"))
    actual = parse_time(row.get("actualTime")) if row.get("actualTime") else None
    estimate = parse_time(row.get("liveEstimateTime")) if row.get("liveEstimateTime") else None

    # Default display and comparison values
    if not sched:
        return "?", datetime.now(timezone.utc)

    if actual:
        delay = int((actual - sched).total_seconds() / 60)
        if delay != 0:
            text = f"{format_hki(sched)} → {format_hki(actual)} ({delay:+} min)"
        else:
            text = f"{format_hki(sched)}"
        return text, actual
    elif estimate:
        delay = int((estimate - sched).total_seconds() / 60)
        if delay != 0:
            text = f"{format_hki(sched)} → {format_hki(estimate)} ({delay:+} min)"
        else:
            text = f"{format_hki(sched)}"
        return text, estimate
    else:
        return f"{format_hki(sched)}", sched

def get_trains(origin: str, destination: str):
    """
    Returns the next commuter trains from origin to destination.
    Output: list of tuples (sched_time, trainNumber, time_text, best_dt, platform, rows)
    """
    trains = fetch_station_window(origin)
    now_utc = datetime.now(timezone.utc)
    results = []

    for tr in trains:
        if tr.get("commuterLineID") != TRAIN_LINE:
            continue

        rows = tr["timeTableRows"]
        dep = next((r for r in rows if r["stationShortCode"] == origin and r["type"] == "DEPARTURE"), None)
        arr = next((r for r in rows if r["stationShortCode"] == destination and r["type"] == "ARRIVAL"), None)
        if not dep or not arr or rows.index(dep) >= rows.index(arr):
            continue

        sched_time = parse_time(dep["scheduledTime"])
        if sched_time < now_utc - timedelta(minutes=PAST_MINUTES):
            continue

        text, best = extract_best_time(dep)
        platform = dep.get("commercialTrack", "—")
        results.append((sched_time, tr["trainNumber"], text, best, platform, rows))

    return sorted(results, key=lambda x: x[0])

# ----------------------------
# 6) STATION HELPERS
# ----------------------------
def final_destination_name(rows, station_names: dict) -> str:
    """Return full human-readable name of train’s final stop."""
    final_row = next((r for r in reversed(rows) if r.get("type") == "ARRIVAL"), rows[-1])
    code = final_row.get("stationShortCode", "—")
    return station_names.get(code, code)

# ----------------------------
# 7) STATUS CHECK (optional)
# ----------------------------
def check_digitraffic_status(endpoint_name="Rail /api/v1/live-trains"):
    """Check API status page for service health."""
    try:
        r = requests.get("https://status.digitraffic.fi/api/v2/components.json", timeout=4)
        if r.status_code != 200:
            return None
        for comp in r.json().get("components", []):
            if comp.get("name") == endpoint_name:
                return comp.get("status")  # e.g. "operational"
    except Exception:
        return None

# ----------------------------
# 8) TERMINAL TEST
# ----------------------------
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(
        usage="%(prog)s [--time HH:MM] [--from AIN|HKI]",
        description="Fetch R-train schedules"
    )
    parser.add_argument("--time", type=str, help="Show trains departing at or after this time (HH:MM format)")
    parser.add_argument("--from", dest="from_station", type=str, help="Departure station (e.g., AIN or HKI)")
    args = parser.parse_args()
 
    
    # Determine origin and destination
    if args.from_station:
        from_code = args.from_station.upper()
        if from_code == HOME_STATIONS["origin"]:
            origin = HOME_STATIONS["origin"]
            dest = HOME_STATIONS["destination"]
        elif from_code == HOME_STATIONS["destination"]:
            origin = HOME_STATIONS["destination"]
            dest = HOME_STATIONS["origin"]
        else:
            print(f"⚠️ Unknown station: {args.from_station}")
            print(f"Valid options: {HOME_STATIONS['origin']}, {HOME_STATIONS['destination']}")
            exit(1)
    else:
        # Default: both directions
        origin = HOME_STATIONS["origin"]
        dest = HOME_STATIONS["destination"]
    
    # Look up full station names
    origin_name = STATIONS.get(origin, origin)
    dest_name = STATIONS.get(dest, dest)

    # Parse time filter if provided
    filter_time = None
    if args.time:
        try:
            hour, minute = map(int, args.time.split(':'))
            now_hki = datetime.now(TZ)
            filter_time = now_hki.replace(hour=hour, minute=minute, second=0, microsecond=0)
            
            # If specified time has already passed today, look for tomorrow
            if filter_time <= now_hki:
                filter_time = filter_time + timedelta(days=1)
            
            filter_time = filter_time.astimezone(timezone.utc)
        except ValueError:
            print("⚠️ Invalid time format. Use HH:MM (e.g., 08:00)")
            exit(1)

    # If --from specified, show only that direction
    if args.from_station:
        print(f"Fetching next {TRAIN_LINE}-trains from {origin_name} → {dest_name}:\n")
        trains_data = get_trains(origin, dest)
        
        if filter_time:
            trains_data = [(st, num, txt, bdt, plat, rows) 
                           for st, num, txt, bdt, plat, rows in trains_data 
                           if st >= filter_time]
        
        if not trains_data:
            print("No trains found.")
        else:
            for sched_time, num, text, best_dt, platform, rows in trains_data[:5]:
                final_dest = final_destination_name(rows, STATIONS)
                print(f"→ To {final_dest} ({TRAIN_LINE} {num})")
                print(f"  Departs: {text}")
                print(f"  Platform: {platform}\n")
    
    # Otherwise show both directions (original behavior)
    else:
        print(f"Fetching next {TRAIN_LINE}-trains from {origin_name} → {dest_name}:\n")
        trains_data = get_trains(origin, dest)
        
        if filter_time:
            trains_data = [(st, num, txt, bdt, plat, rows) 
                           for st, num, txt, bdt, plat, rows in trains_data 
                           if st >= filter_time]
        
        if not trains_data:
            print("No trains found.")
        else:
            for sched_time, num, text, best_dt, platform, rows in trains_data[:5]:
                final_dest = final_destination_name(rows, STATIONS)
                print(f"→ To {final_dest} ({TRAIN_LINE} {num})")
                print(f"  Departs: {text}")
                print(f"  Platform: {platform}\n")
        
        print(f"Fetching next {TRAIN_LINE}-trains from {dest_name} → {origin_name}:\n")
        trains_data = get_trains(dest, origin)
        
        if filter_time:
            trains_data = [(st, num, txt, bdt, plat, rows) 
                           for st, num, txt, bdt, plat, rows in trains_data 
                           if st >= filter_time]
        
        if not trains_data:
            print("No trains found.")
        else:
            for sched_time, num, text, best_dt, platform, rows in trains_data[:5]:
                final_dest = final_destination_name(rows, STATIONS)
                print(f"→ To {final_dest} ({TRAIN_LINE} {num})")
                print(f"  Departs: {text}")
                print(f"  Platform: {platform}\n")