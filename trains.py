# -*- coding: utf-8 -*-
"""
=========================================
TRAINS.PY — Fetch live R-train data (config-driven)
=========================================

Reads train line, stations, and timing settings from config.json.
Handles only logic (no Streamlit). Can be used by Streamlit or CLI.

Author: Birgir
Version: 2025-10-29
"""

# ----------------------------
# 1) IMPORTS
# ----------------------------
import requests
from datetime import datetime, timedelta, timezone
from requests.exceptions import ReadTimeout, ConnectionError
import zoneinfo
import json
import os
import time
from functools import lru_cache

# ----------------------------
# 2) CONFIGURATION
# ----------------------------
import os, json, zoneinfo

# Determine config path relative to this file
CONFIG_PATH = os.path.join(os.path.dirname(__file__), "config.json")

def load_config():
    """
    Load configuration shared by all modules.
    Expects config.json generated by config.py.
    """
    if not os.path.exists(CONFIG_PATH):
        raise FileNotFoundError("⚠️ config.json not found — run config.py first.")
    with open(CONFIG_PATH, "r", encoding="utf-8") as f:
        return json.load(f)

# Load config once on import
cfg = load_config()

# --- Extract configuration values ---
TRAIN_LINE = cfg["TRAIN_LINE"]
STATIONS = cfg["STATIONS"]
HOME_STATIONS = cfg["HOME_STATIONS"]
PAST_MINUTES = cfg["PAST_MINUTES"]
FUTURE_MINUTES = cfg["FUTURE_MINUTES"]

TZ = zoneinfo.ZoneInfo("Europe/Helsinki")

# --- API headers ---
HEADERS = {
    "Digitraffic-User": cfg.get("USER_AGENT", "Birgir-ainola-dashboard/1.0")
}

STATIONS_METADATA_URL = "https://rata.digitraffic.fi/api/v1/metadata/stations"
TRAIN_LOCATIONS_GEOJSON_URL = "https://rata.digitraffic.fi/api/v1/train-locations.geojson/latest"
# Digitraffic moved their GraphQL endpoint under a nested /graphql path in 2024.
# The previous url ("/api/v2/graphql") now returns HTTP 404 which meant our
# first-tier live train lookup always failed and we never displayed markers on
# the map.  Point the client to the new canonical endpoint so the GraphQL call
# succeeds again before falling back to the REST feed.
TRAIN_LOCATIONS_GRAPHQL_URL = "https://rata.digitraffic.fi/api/v2/graphql/graphql"

# ----------------------------
# 3) TIME HELPERS
# ----------------------------
def parse_time(ts: str) -> datetime:
    """Convert ISO8601 string like '2024-01-26T12:05:00.000Z' → timezone-aware UTC datetime."""
    return datetime.fromisoformat(ts.replace("Z", "+00:00"))

def format_hki(dt: datetime) -> str:
    """Format datetime to Helsinki local time HH:MM."""
    return dt.astimezone(TZ).strftime("%H:%M")

# ----------------------------
# 4) FETCH FUNCTIONS
# ----------------------------
def get_json(url, retries=2, timeout=6):
    """Safely fetch JSON payload from Digitraffic with retry logic."""
    for attempt in range(retries + 1):
        try:
            response = requests.get(url, headers=HEADERS, timeout=timeout)
            response.raise_for_status()
            return response.json()
        except (ConnectionError, ReadTimeout):
            if attempt == retries:
                return None
            time.sleep(0.4)
        except requests.RequestException:
            return None


def fetch_station_window(station_code: str, before=PAST_MINUTES, after=FUTURE_MINUTES, limit=500, retries=2):
    """
    Fetch trains from Digitraffic API for a specific station.
    Retries automatically if network timeout occurs.
    """
    url = (
        f"https://rata.digitraffic.fi/api/v1/live-trains/station/{station_code}"
        f"?departing_trains={limit}&minutes_before_departure={before}&minutes_after_departure={after}"
    )

    for attempt in range(retries + 1):
        try:
            r = requests.get(url, headers=HEADERS, timeout=6)
            r.raise_for_status()
            return r.json()
        except (ConnectionError, ReadTimeout):
            if attempt == retries:
                return []
            time.sleep(0.4)  # short delay before retry


@lru_cache(maxsize=1)
def _station_metadata():
    """Fetch metadata for all Finnish railway stations (cached)."""
    data = get_json(STATIONS_METADATA_URL)
    if not data:
        return []
    return data


def get_station_coordinates(station_codes):
    """Return mapping of station code → {lat, lon, name} for requested stations."""
    wanted = {code.upper() for code in station_codes}
    coords = {}
    for station in _station_metadata():
        code = station.get("stationShortCode")
        if not code or code.upper() not in wanted:
            continue
        lat = station.get("latitude")
        lon = station.get("longitude")
        if lat is None or lon is None:
            continue
        coords[code.upper()] = {
            "lat": lat,
            "lon": lon,
            "name": station.get("stationName", code),
        }
    return coords


def fetch_live_trains_graphql(train_line: str = TRAIN_LINE):
    """Fetch live train positions for the given line using the Digitraffic GraphQL API."""
    line = (train_line or "").strip().upper()
    if not line:
        return []

    query_line = line.replace('"', "")
    query = f"""
    {{
      currentlyRunningTrains(
        where: {{
          and: [
            {{ operator: {{ shortCode: {{ equals: \"vr\" }} }} }}
            {{ commuterLineid: {{ equals: \"{query_line}\" }} }}
          ]
        }}
        orderBy: {{ trainNumber: DESCENDING }}
      ) {{
        trainNumber
        commuterLineid
        trainLocations(orderBy: {{ timestamp: DESCENDING }}, take: 1) {{
          timestamp
          speed
          heading
          location
        }}
      }}
    }}
    """

    headers = dict(HEADERS)
    headers.setdefault("Content-Type", "application/json")

    try:
        response = requests.post(
            TRAIN_LOCATIONS_GRAPHQL_URL,
            json={"query": query},
            headers=headers,
            timeout=10,
        )
        response.raise_for_status()
        data = response.json()
    except Exception as exc:
        print(f"⚠️ Failed to fetch {line}-line trains via GraphQL: {exc}")
        return []

    trains = []
    for train in data.get("data", {}).get("currentlyRunningTrains", []):
        locations = train.get("trainLocations") or []
        if not locations:
            continue

        latest = locations[0]
        location = latest.get("location") or {}
        coords = location.get("coordinates") or []
        if len(coords) < 2:
            continue

        lon, lat = coords[0], coords[1]
        trains.append(
            {
                "trainNumber": train.get("trainNumber"),
                "line": train.get("commuterLineid") or line,
                "timestamp": latest.get("timestamp"),
                "speed": latest.get("speed"),
                "bearing": latest.get("heading"),
                "lat": lat,
                "lon": lon,
            }
        )

    if trains:
        print(f"Fetched {len(trains)} live {line}-line trains via GraphQL")
    return trains


def _bbox_query_string() -> str:
    """Return bbox query string derived from config ("xmin,ymin,xmax,ymax")."""
    bbox_cfg = cfg.get("BOUNDING_BOX") or {}
    try:
        return ",".join(
            str(bbox_cfg[key])
            for key in ("X_MIN", "Y_MIN", "X_MAX", "Y_MAX")
        )
    except KeyError:
        return ""


def fetch_train_locations(train_line: str = TRAIN_LINE):
    """Fetch latest live locations for the configured commuter line."""
    graphql_trains = fetch_live_trains_graphql(train_line)
    if graphql_trains:
        return graphql_trains

    url = TRAIN_LOCATIONS_GEOJSON_URL
    bbox_query = _bbox_query_string()
    if bbox_query:
        url = f"{url}?bbox={bbox_query}"

    payload = get_json(url)
    if not payload:
        return []

    results = []
    wanted_line = (train_line or "").upper()

    # Handle the GeoJSON structure introduced in 2024 while staying backward compatible
    if isinstance(payload, dict) and isinstance(payload.get("features"), list):
        entries = payload.get("features") or []
        for feature in entries:
            props = feature.get("properties") or {}
            geometry = feature.get("geometry") or {}
            coords = geometry.get("coordinates") or []
            if len(coords) < 2:
                continue

            line = props.get("commuterLineId") or props.get("commuterLineID") or ""
            normalized_line = (line or "").upper()
            if wanted_line and normalized_line and normalized_line != wanted_line:
                continue

            lon, lat = coords[0], coords[1]
            results.append(
                {
                    "trainNumber": props.get("trainNumber"),
                    "line": line or train_line,
                    "speed": props.get("speed"),
                    "bearing": props.get("heading") or props.get("bearing"),
                    "timestamp": props.get("timestamp"),
                    "lat": lat,
                    "lon": lon,
                }
            )
    else:
        for entry in payload:
            line = entry.get("commuterLineID") or entry.get("commuterLineId") or ""
            normalized_line = (line or "").upper()
            if wanted_line and normalized_line and normalized_line != wanted_line:
                continue

            location = entry.get("location", {})
            coords = location.get("coordinates") or []
            if len(coords) < 2:
                continue

            lon, lat = coords[0], coords[1]
            results.append(
                {
                    "trainNumber": entry.get("trainNumber"),
                    "line": line or train_line,
                    "speed": entry.get("speed"),
                    "bearing": entry.get("bearing"),
                    "timestamp": entry.get("timestamp") or entry.get("timeStamp"),
                    "lat": lat,
                    "lon": lon,
                }
            )

    return results

# ----------------------------
# 5) TRAIN LOGIC
# ----------------------------
def extract_best_time(row):
    """
    Return (text, best_dt) for the given timetable row.

    text → formatted string like:
        "08:34 → 08:39 (+5 min)" (if delayed)
        or just "08:34" if on time or no delay info.
    best_dt → datetime of actual or estimate (for sorting/comparisons)
    """
    sched = parse_time(row.get("scheduledTime"))
    actual = parse_time(row.get("actualTime")) if row.get("actualTime") else None
    estimate = parse_time(row.get("liveEstimateTime")) if row.get("liveEstimateTime") else None

    # Default display and comparison values
    if not sched:
        return "?", datetime.now(timezone.utc)

    if actual:
        delay = int((actual - sched).total_seconds() / 60)
        if delay != 0:
            text = f"{format_hki(sched)} → {format_hki(actual)} ({delay:+} min)"
        else:
            text = f"{format_hki(sched)}"
        return text, actual
    elif estimate:
        delay = int((estimate - sched).total_seconds() / 60)
        if delay != 0:
            text = f"{format_hki(sched)} → {format_hki(estimate)} ({delay:+} min)"
        else:
            text = f"{format_hki(sched)}"
        return text, estimate
    else:
        return f"{format_hki(sched)}", sched

def get_trains(origin: str, destination: str):
    """
    Returns the next commuter trains from origin to destination.
    Output: list of tuples (sched_time, trainNumber, time_text, best_dt, platform, rows)
    """
    trains = fetch_station_window(origin)
    now_utc = datetime.now(timezone.utc)
    results = []

    for tr in trains:
        if tr.get("commuterLineID") != TRAIN_LINE:
            continue

        rows = tr["timeTableRows"]
        dep = next((r for r in rows if r["stationShortCode"] == origin and r["type"] == "DEPARTURE"), None)
        arr = next((r for r in rows if r["stationShortCode"] == destination and r["type"] == "ARRIVAL"), None)
        if not dep or not arr or rows.index(dep) >= rows.index(arr):
            continue

        sched_time = parse_time(dep["scheduledTime"])
        if sched_time < now_utc - timedelta(minutes=PAST_MINUTES):
            continue

        text, best = extract_best_time(dep)
        platform = dep.get("commercialTrack", "—")
        results.append((sched_time, tr["trainNumber"], text, best, platform, rows))

    return sorted(results, key=lambda x: x[0])

# ----------------------------
# 6) STATION HELPERS
# ----------------------------
def final_destination_name(rows, station_names: dict) -> str:
    """Return full human-readable name of train’s final stop."""
    final_row = next((r for r in reversed(rows) if r.get("type") == "ARRIVAL"), rows[-1])
    code = final_row.get("stationShortCode", "—")
    return station_names.get(code, code)

# ----------------------------
# 7) STATUS CHECK (optional)
# ----------------------------
def check_digitraffic_status(endpoint_name="Rail /api/v1/live-trains"):
    """Check API status page for service health."""
    try:
        r = requests.get("https://status.digitraffic.fi/api/v2/components.json", timeout=4)
        if r.status_code != 200:
            return None
        for comp in r.json().get("components", []):
            if comp.get("name") == endpoint_name:
                return comp.get("status")  # e.g. "operational"
    except Exception:
        return None

# ----------------------------
# 8) TERMINAL TEST
# ----------------------------
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(
        usage="%(prog)s [--time HH:MM] [--from AIN|HKI]",
        description="Fetch R-train schedules"
    )
    parser.add_argument("--time", type=str, help="Show trains departing at or after this time (HH:MM format)")
    parser.add_argument("--from", dest="from_station", type=str, help="Departure station (e.g., AIN or HKI)")
    args = parser.parse_args()
 
    
    # Determine origin and destination
    if args.from_station:
        from_code = args.from_station.upper()
        if from_code == HOME_STATIONS["origin"]:
            origin = HOME_STATIONS["origin"]
            dest = HOME_STATIONS["destination"]
        elif from_code == HOME_STATIONS["destination"]:
            origin = HOME_STATIONS["destination"]
            dest = HOME_STATIONS["origin"]
        else:
            print(f"⚠️ Unknown station: {args.from_station}")
            print(f"Valid options: {HOME_STATIONS['origin']}, {HOME_STATIONS['destination']}")
            exit(1)
    else:
        # Default: both directions
        origin = HOME_STATIONS["origin"]
        dest = HOME_STATIONS["destination"]
    
    # Look up full station names
    origin_name = STATIONS.get(origin, origin)
    dest_name = STATIONS.get(dest, dest)

    # Parse time filter if provided
    filter_time = None
    if args.time:
        try:
            hour, minute = map(int, args.time.split(':'))
            now_hki = datetime.now(TZ)
            filter_time = now_hki.replace(hour=hour, minute=minute, second=0, microsecond=0)
            
            # If specified time has already passed today, look for tomorrow
            if filter_time <= now_hki:
                filter_time = filter_time + timedelta(days=1)
            
            filter_time = filter_time.astimezone(timezone.utc)
        except ValueError:
            print("⚠️ Invalid time format. Use HH:MM (e.g., 08:00)")
            exit(1)

    # If --from specified, show only that direction
    if args.from_station:
        print(f"Fetching next {TRAIN_LINE}-trains from {origin_name} → {dest_name}:\n")
        trains_data = get_trains(origin, dest)
        
        if filter_time:
            trains_data = [(st, num, txt, bdt, plat, rows) 
                           for st, num, txt, bdt, plat, rows in trains_data 
                           if st >= filter_time]
        
        if not trains_data:
            print("No trains found.")
        else:
            for sched_time, num, text, best_dt, platform, rows in trains_data[:5]:
                final_dest = final_destination_name(rows, STATIONS)
                print(f"→ To {final_dest} ({TRAIN_LINE} {num})")
                print(f"  Departs: {text}")
                print(f"  Platform: {platform}\n")
    
    # Otherwise show both directions (original behavior)
    else:
        print(f"Fetching next {TRAIN_LINE}-trains from {origin_name} → {dest_name}:\n")
        trains_data = get_trains(origin, dest)
        
        if filter_time:
            trains_data = [(st, num, txt, bdt, plat, rows) 
                           for st, num, txt, bdt, plat, rows in trains_data 
                           if st >= filter_time]
        
        if not trains_data:
            print("No trains found.")
        else:
            for sched_time, num, text, best_dt, platform, rows in trains_data[:5]:
                final_dest = final_destination_name(rows, STATIONS)
                print(f"→ To {final_dest} ({TRAIN_LINE} {num})")
                print(f"  Departs: {text}")
                print(f"  Platform: {platform}\n")
        
        print(f"Fetching next {TRAIN_LINE}-trains from {dest_name} → {origin_name}:\n")
        trains_data = get_trains(dest, origin)
        
        if filter_time:
            trains_data = [(st, num, txt, bdt, plat, rows) 
                           for st, num, txt, bdt, plat, rows in trains_data 
                           if st >= filter_time]
        
        if not trains_data:
            print("No trains found.")
        else:
            for sched_time, num, text, best_dt, platform, rows in trains_data[:5]:
                final_dest = final_destination_name(rows, STATIONS)
                print(f"→ To {final_dest} ({TRAIN_LINE} {num})")
                print(f"  Departs: {text}")
                print(f"  Platform: {platform}\n")